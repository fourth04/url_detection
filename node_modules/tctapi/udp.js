var udp = exports;
var dgram = require('dgram');

var classConf = {
    "1": [2,4,18,31,32,33,35,38,83,1113,2100,2097152,4194304,33554432],
    "2": [5,7,8,39,49,52,53,259,263,2257,8198,8199,8200,8201,16386,16777216],
    "3": [10,13,42,8192,8193,8195,8197,32768,8388608,67108864,67108866],
    "4": [17,24,25,26,27,28,36,37,76,512,598,65536,65537,524288,524289,1048578],
    "5": [16384,16387],
    "6": [19,20,21,22,29,34,56,257,258],
    "7": [9,14,16,30,40,41,46,47,48,57,62,63,68,82,260,268,270,1111,1112,2048,2300,2302,2305,2400,2401,2402,65538,262144,268435456],
    "8": [6,23,50,64,65,91,92,93,94,95,96,100,101,102,103,104,105,106,107,108]
}

var typeConf = {};

var gPool = [];
var gPoolSize = 0;
var gCurrent = 0;
var gServer = "localhost";
var gPort = 30000;
var gState = {};
var gSeqno = 100;

const STX = 0x02;
const ETX = 0x03;
const REQ_SEQ_TYPE = 1;
const REQ_URL_TYPE = 2;
const REQ_BUFFER_TYPE = 3;
const RESP_CODE_TYPE = 4;
const RESP_SEQ_TYPE = 5;
const RESP_URL_TYPE = 6;
const RESP_EVIL_TYPE = 7;
const RESP_LEVEL_TYPE = 8;
const RESP_PARAM_TYPE = 9;
const RESP_BUFFER_TYPE = 10;

var getNextSeqno = function() {
    return (++gSeqno >= 0xFFFFFF)?100:gSeqno;
}

var getNextSocket = function() {
    var current = (gCurrent >= gPoolSize)?0:gCurrent;
    gCurrent ++;
    return gPool[current];
}

udp.init = function(poolSize,server,port) {
    gPoolSize = poolSize;
    gServer = server;
    gPort = port;

    var decode = function(msg) {
        if(msg.length <= 2) {
            console.log("Return message length in correct");
            return null;
        }
        if(msg[0] != STX || msg[msg.length-1] != ETX) {
            console.log("Message format error!");
            return null;
        }
        var offset = 1;
        var ret = {};

        while(offset < msg.length - 1) {
            var ucTag = msg[offset++];
            var valueLen = msg.readInt32BE(offset);
            offset += 4;
            switch(ucTag) {
                case RESP_CODE_TYPE:
                    ret.code = msg[offset];
                    break;
                case RESP_SEQ_TYPE:
                    ret.seqno = msg.readInt32BE(offset);
                    break;
                case RESP_URL_TYPE:
                    ret.urlType = msg.readInt32BE(offset);
                    break;
                case RESP_EVIL_TYPE:
                    ret.evilType = msg.readInt32BE(offset);
                    break;
                case RESP_LEVEL_TYPE:
                    ret.level = msg.readInt32BE(offset);
                    break;
                case RESP_PARAM_TYPE:
                    break;
                case RESP_BUFFER_TYPE:
                    break;
            }
            offset += valueLen;
        }
        return ret;
    }

    for(var i = 0; i < gPoolSize; i ++) {
        var socket = dgram.createSocket('udp4');
        socket.on('message',function(msg,rinfo) {
            var data = decode(msg);
            if(!data) {
                console.log("Incorrect message ");
                console.log(msg);
            }
            var seqno = data.seqno;
            if(gState[seqno]) {
                clearTimeout(gState[seqno].timerId);
                var err = null;
                if(data.code != 0) {
                    err = new Error("Invalid code returned "+data.code);
                }
                var evilClass = (data.evilType != 0)?typeConf[data.evilType]:0
                gState[seqno].cb(err,{url:gState[seqno].url,urlType:data.urlType,evilType:data.evilType,evilClass:evilClass,level:data.level});
                delete gState[seqno];
            }
        });
        gPool.push(socket);
    }

    for(var key in classConf) {
        var arr = classConf[key];
        for(var i = 0; i < arr.length; i ++) typeConf[i] = parseInt(key);
    }
}

udp.send = function(url,cb) {
    var seqno = getNextSeqno();
    var socket = getNextSocket();
    var encode = function(seqno,url) {
        var buf = new Buffer(200);
        var offset = 0;
        buf[offset] = STX;
        offset ++;

        buf[offset] = REQ_SEQ_TYPE;
        offset ++;
        buf.writeInt32BE(4,offset);
        offset += 4;
        buf.writeInt32BE(seqno,offset);
        offset += 4;

        buf[offset] = REQ_URL_TYPE;
        offset ++;
        buf.writeInt32BE(url.length,offset);
        offset += 4;
        buf.write(url,offset);
        offset += url.length;

        buf[offset++] = ETX;

        var output = new Buffer(offset);
        buf.copy(output,0,0,offset);
        return output;
    }
    var timeout = function(seqno) {
        if(gState[seqno]) {
            gState[seqno].cb(new Error('Timeout'),null);
            delete gState[seqno];
        }
    };

    socket.send(encode(seqno,url),gPort,gServer);
    if(gState[seqno]) {
        clearTimeout(gState[seqno].timerId);
        timeout(seqno);
    }
    gState[seqno] = {};
    gState[seqno].cb = cb;
    gState[seqno].url = url;
    gState[seqno].timerId = setTimeout(timeout,10*1000,seqno);
}
