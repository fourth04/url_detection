#include <node.h>
#include <v8.h>
#include "common.h"
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
extern "C" {
#include "urllibhandler.h"
}


#define LOG(format,...) \
    do{\
       printf("[ TAPI ]\t" format "\n",\
          ##__VA_ARGS__);\
    }while(0)

#define MAX_PARA_LEN 128
#define URLLIB_SHM_LOCAL_KEY 263700
#define URLLIB_SHM_CLOUD_KEY 263785
#define URLLIB_MAX_CNT 150000000

using namespace v8;

static void WorkAsync(uv_work_t *req)
{
    // 使用多线程异步调用UrlLibDetect，本函数负责新建一个线程进行UrlLibDetect
    Work *work = static_cast<Work *>(req->data);
    const char *ptrUrl = work->url.c_str();
    unsigned int uiUrlType = 0;
    unsigned int uiEvilType = 0;
    unsigned int uiLevel = 0;
    char szParameter[MAX_PARA_LEN] = {0};

    int iRet = UrlLibDetect(ptrUrl,&uiUrlType, &uiEvilType, &uiLevel,szParameter);
    if(iRet != 0x00 && iRet != 0x52){
        LOG("%s\tUrlLibDetect url failed! iRet:%#x\n",ptrUrl,iRet);
        char szError[64];
        sprintf(szError,"UrlLibDetect url failed! iRet:%#x",iRet);
        work->ret = iRet;
    } else {
        work->ret = 0;
        work->urlType = uiUrlType;
        work->urlEvilType = uiEvilType;
        work->urlLevel = uiLevel;
        if(uiEvilType != 0) {
            int r = convType2Class(uiEvilType, &work->urlEvilClass);
            if(r == 0x62) {
                LOG("Error: typeConvFile is not correctly set in license file");
            }
        }
    }
}

static void WorkAsyncComplete(uv_work_t *req,int status)
{
    // 使用多线程异步调用UrlLibDetect，本函数负责接收刚才新建线程处理完之后返回的数据，并使用绑定的回调函数来调用它
    Isolate * isolate = Isolate::GetCurrent();
    HandleScope handleScope(isolate);
    Work *work = static_cast<Work *>(req->data);
    // 将传入的回调函数转换成C能识别的类型
    Local<Function> callback = Local<Function>::New(isolate, work->callback);

    // 线程处理完之后正常返回时
    if(work->ret == 0) {
        // 初始化回调函数将要使用的参数个数为2
        const unsigned argc = 2;
        // 初始化回调函数将要使用的参数数组，0位为error，1位为线程处理完之后返回的值result
        Local<Value> argv[argc] = {
            Local<Value>::New(isolate,Null(isolate)),
            Local<Value>::New(isolate,Object::New(isolate))
        };
        // argv参数数组的1位实例化一个C的对象result，下面就是将线程处理完之后返回的值存放到result的过程
        Local<Object> result = Local<Object>::Cast(argv[1]);
        result->Set(String::NewFromUtf8(isolate, "url"),String::NewFromUtf8(isolate,work->url.c_str()));
        result->Set(String::NewFromUtf8(isolate, "urlType"),Integer::New(isolate,work->urlType));
        result->Set(String::NewFromUtf8(isolate, "evilType"),Integer::New(isolate,work->urlEvilType));
        result->Set(String::NewFromUtf8(isolate, "evilClass"),Integer::New(isolate,work->urlEvilClass));
        result->Set(String::NewFromUtf8(isolate, "level"),Integer::New(isolate,work->urlLevel));
        // 将赋值完值之后的参数个数，参数数组等数据传入回调函数进行回调函数调用
        callback->Call(isolate->GetCurrentContext()->Global(), argc, argv);
    // 线程处理完之后异常返回时
    } else {
        char szError[64];
        sprintf(szError,"UrlLibDetect url failed! iRet:%#x",work->ret);
        Local<Value> err = Exception::Error(String::NewFromUtf8(isolate,szError));
        const unsigned argc = 2;
        Local<Value> argv[argc] = {err,Local<Value>::New(isolate,Null(isolate))};
        // 将赋值完值之后的参数个数，参数数组等信息传入回调函数进行回调函数调用
        callback->Call(isolate->GetCurrentContext()->Global(), argc, argv);
    }
    work->callback.Reset();
    delete work;
}

void _init(const FunctionCallbackInfo<Value>& args) {
    Isolate* isolate = args.GetIsolate();

    if(args.Length() < 1) {
        isolate->ThrowException(Exception::TypeError(
           String::NewFromUtf8(isolate, "Argument not existed!")));
        return;
    }
    if(!args[0]->IsString()) {
        isolate->ThrowException(Exception::TypeError(
           String::NewFromUtf8(isolate, "Argument must be a string!")));
        return;
    }
    String::Utf8Value conf(args[0]->ToString());
    String::Utf8Value mode(args[1]->ToString());
    LOG("conf file: %s mode: %s",*conf,*mode);
    int iErrCode = 0;
    unsigned int key;
    if(!strcmp(*mode,"cloud")) {
        key = URLLIB_SHM_CLOUD_KEY;
    } else if(!strcmp(*mode,"local")) {
        key = URLLIB_SHM_LOCAL_KEY;
    } else {
        isolate->ThrowException(Exception::TypeError(
           String::NewFromUtf8(isolate, "Invalid mode. local&cloud are allowed!")));
        return;
    }
    if(!UrlLibInit(key,URLLIB_MAX_CNT,*conf,&iErrCode))
    {
        LOG("UrlLibInit Failed\tErrcode:%#x\n",iErrCode);
        isolate->ThrowException(Exception::TypeError(
           String::NewFromUtf8(isolate, "Tencent API init failed!")));
        return;
    }
    LOG("Tencent API init OK!");
}

void _detectSync(const FunctionCallbackInfo<Value>& args) {
    Isolate* isolate = args.GetIsolate();
    HandleScope handleScope(isolate);

    if(args.Length() < 1) {
       isolate->ThrowException(Exception::TypeError(
          String::NewFromUtf8(isolate, "Argument not existed!")));
       return;
    }
    if(!args[0]->IsString()) {
       isolate->ThrowException(Exception::TypeError(
          String::NewFromUtf8(isolate, "Argument must be a string!")));
       return;
    }
    String::Utf8Value url(args[0]->ToString());
    Local<Function> cb = Local<Function>::Cast(args[1]);

    char *ptrUrl = *url;
    unsigned int uiUrlType = 0;
    unsigned int uiEvilType = 0;
    unsigned int uiEvilClass = 0;
    unsigned int uiLevel = 0;
    char szParameter[MAX_PARA_LEN] = {0};
    int iRet = UrlLibDetect(ptrUrl,&uiUrlType, &uiEvilType, &uiLevel,szParameter);
    if(iRet != 0x00 && iRet != 0x52){
        LOG("%s\tUrlLibDetect url failed! iRet:%#x\n",ptrUrl,iRet);
        char szError[64];
        sprintf(szError,"UrlLibDetect url failed! iRet:%#x",iRet);
        Local<Value> err = Exception::Error(String::NewFromUtf8(isolate,szError));
        const unsigned argc = 1;
        Local<Value> argv[argc] = { err };
        cb->Call(Null(isolate), argc, argv);
    } else {
        const unsigned argc = 2;
        Local<Value> argv[argc] = {
            Local<Value>::New(isolate,Null(isolate)),
            Local<Value>::New(isolate,Object::New(isolate))
        };
        if(uiEvilType != 0) {
            int r = convType2Class(uiEvilType, &uiEvilClass);
            if(r == 0x62) {
                LOG("Error: typeConvFile is not correctly set in license file");
            }
        }
        Local<Object> result = Local<Object>::Cast(argv[1]);
        result->Set(String::NewFromUtf8(isolate, "url"),String::NewFromUtf8(isolate,ptrUrl));
        result->Set(String::NewFromUtf8(isolate, "urlType"),Integer::New(isolate,uiUrlType));
        result->Set(String::NewFromUtf8(isolate, "evilType"),Integer::New(isolate,uiEvilType));
        result->Set(String::NewFromUtf8(isolate, "evilClass"),Integer::New(isolate,uiEvilClass));
        result->Set(String::NewFromUtf8(isolate, "level"),Integer::New(isolate,uiLevel));
        cb->Call(Null(isolate), argc, argv);
    }
}

void _detectAsync(const FunctionCallbackInfo<Value>& args) {
    Isolate* isolate = args.GetIsolate();
    HandleScope handleScope(isolate);

    if(args.Length() < 1) {
       isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "Argument not existed!")));
       return;
    }
    if(!args[0]->IsString()) {
       isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "Argument must be a string!")));
       return;
    }

    // 调用_detectAsync时的第一个参数，这里为url的字符串，需要转换成C的数据类型
    String::Utf8Value url(args[0]->ToString());
    // 调用_detectAsync时的第二个参数，一般为回调函数，需要转换成C的数据类型
    Local<Function> cb = Local<Function>::Cast(args[1]);

/*
    自定义类Work，用户线程调用以及线程回调时共享数据
    class Work {
        public:
            uv_work_t    request;
            Persistent<Function> callback;
            std::string url;
            unsigned int ret;
            unsigned int urlType;
            unsigned int urlEvilType;
            unsigned int urlEvilClass;
            unsigned int urlLevel;

            Work() {};
    };
    request字段是必须有的，并且它的data指针指向我们的数据，即本对象
    callback字段指向回调函数，使用callback.Reset()绑定回调函数
    isolate字段可能不需要，可以直接使用全局
 */
    Work * work = new Work();
    work->request.data = work;
    // 绑定回调函数为第二个参数指向的回调函数
    work->callback.Reset(isolate, cb);

    // 通过work结构体给线程传递参数
    work->url = std::string(*url);
    uv_queue_work(uv_default_loop(), &(work->request), WorkAsync, WorkAsyncComplete);

    // args.GetReturnValue().Set(Undefined(isolate));
}

void Init(Handle<Object> exports) {
    NODE_SET_METHOD(exports, "init",_init);
    NODE_SET_METHOD(exports, "detectAsync", _detectAsync);
    NODE_SET_METHOD(exports, "detectSync", _detectSync);
}

NODE_MODULE(tapi, Init)
